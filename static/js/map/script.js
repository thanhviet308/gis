/* eslint-disable no-undef */
/**
 * control layers outside the map
 */

// config map
let config = {
  minZoom: 7,
  maxZoom: 18,
  fullscreenControl: true
};
// magnification with which the map will start
const zoom = 18;
// co-ordinates
const lat = 10.8231;
const lng = 106.6297;

// calling map
const map = L.map("map", config).setView([lat, lng], zoom);

// Used to load and display tile layers on the map
// Most tile servers require attribution, which you can set under `Layer`
L.tileLayer("https://tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution:
    '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
}).addTo(map);

// T·∫°o bi·∫øn ƒë·ªÉ l∆∞u tr·ªØ marker v·ªã tr√≠ c·ªßa ng∆∞·ªùi d√πng
let userLocationMarker;
let userLocationCircle;

// Th√™m n√∫t hi·ªÉn th·ªã v·ªã tr√≠ ng∆∞·ªùi d√πng
const locationButton = L.control({ position: 'topleft' });
locationButton.onAdd = function () {
  const div = L.DomUtil.create('div', 'leaflet-bar leaflet-control');
  div.innerHTML = '<a href="#" title="Hi·ªÉn th·ªã v·ªã tr√≠ c·ªßa t√¥i" style="font-size: 18px;">üìç</a>';
  div.style.background = 'white';
  div.style.cursor = 'pointer';

  div.onclick = function () {
    getCurrentLocation();
    return false;
  };

  return div;
};
locationButton.addTo(map);

// H√†m l·∫•y v·ªã tr√≠ hi·ªán t·∫°i c·ªßa ng∆∞·ªùi d√πng
function getCurrentLocation() {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      // Th√†nh c√¥ng
      function (position) {
        const userLat = position.coords.latitude;
        const userLng = position.coords.longitude;
        const accuracy = position.coords.accuracy;

        // X√≥a marker v√† circle c≈© n·∫øu ƒë√£ t·ªìn t·∫°i
        if (userLocationMarker) {
          map.removeLayer(userLocationMarker);
        }
        if (userLocationCircle) {
          map.removeLayer(userLocationCircle);
        }

        // T·∫°o marker v·ªã tr√≠ ng∆∞·ªùi d√πng
        userLocationMarker = L.marker([userLat, userLng], {
          icon: L.divIcon({
            className: 'user-location',  // Th√™m l·ªõp CSS ƒë·ªÉ t·∫°o ki·ªÉu
            html: "<span class='emoji'>üìç</span>",  // Bi·ªÉu t∆∞·ª£ng v·ªã tr√≠ ng∆∞·ªùi d√πng
            iconSize: [40, 40],  // ƒêi·ªÅu ch·ªânh k√≠ch th∆∞·ªõc t·ªïng th·ªÉ c·ªßa icon
            iconAnchor: [20, 20],  // CƒÉn gi·ªØa icon (x,y v·ªã tr√≠ gi·ªØa c·ªßa icon)
            popupAnchor: [0, -25],  // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ popup
          })
        }).addTo(map)
          .bindPopup('V·ªã tr√≠ c·ªßa b·∫°n')
          .openPopup();

        // T·∫°o circle hi·ªÉn th·ªã ƒë·ªô ch√≠nh x√°c
        userLocationCircle = L.circle([userLat, userLng], {
          radius: accuracy,
          color: '#4285F4',
          fillColor: '#4285F4',
          fillOpacity: 0.15
        }).addTo(map);

        // Di chuy·ªÉn map ƒë·∫øn v·ªã tr√≠ ng∆∞·ªùi d√πng
        map.setView([userLat, userLng], zoom);
      },
      // L·ªói
      function (error) {
        let errorMessage;
        switch (error.code) {
          case error.PERMISSION_DENIED:
            errorMessage = 'Ng∆∞·ªùi d√πng ƒë√£ t·ª´ ch·ªëi y√™u c·∫ßu truy c·∫≠p v·ªã tr√≠.';
            break;
          case error.POSITION_UNAVAILABLE:
            errorMessage = 'Th√¥ng tin v·ªã tr√≠ kh√¥ng c√≥ s·∫µn.';
            break;
          case error.TIMEOUT:
            errorMessage = 'Y√™u c·∫ßu l·∫•y v·ªã tr√≠ ng∆∞·ªùi d√πng ƒë√£ h·∫øt th·ªùi gian.';
            break;
          case error.UNKNOWN_ERROR:
            errorMessage = 'ƒê√£ x·∫£y ra l·ªói kh√¥ng x√°c ƒë·ªãnh.';
            break;
        }
        alert(errorMessage);
      },
      // T√πy ch·ªçn
      {
        enableHighAccuracy: true,
        timeout: 5000,
        maximumAge: 0
      }
    );
  } else {
    alert('Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã.');
  }
}

// ------------------------------------------------------------

// async function to load geojson
async function fetchData(url) {
  try {
    const response = await fetch(url);
    const data = await response.json();
    return data;
  } catch (err) {
    console.error(err);
  }
}

// fetching data from geojson
const poiLayers = L.layerGroup().addTo(map);

// center map on the clicked marker
function clickZoom(e) {
  map.setView(e.target.getLatLng(), zoom);
}

let geojsonOpts = {
  pointToLayer: function (feature, latlng) {
    return L.marker(latlng, {
      icon: L.divIcon({
        className: "cinema-icon", // S·ª≠ d·ª•ng CSS ƒë·ªÉ l√†m ƒë·∫πp
        html: "<span class='emoji'>üé•</span>", // Ch·ªâ hi·ªÉn th·ªã emoji
        iconSize: [40, 40], // K√≠ch th∆∞·ªõc t·ªïng th·ªÉ
        iconAnchor: [20, 20], // CƒÉn gi·ªØa icon
        popupAnchor: [0, -25], // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ popup
      }),
    })
      .bindPopup(
        "üé• R·∫°p chi·∫øu phim" +
        "<br><b>" +
        feature.properties.name +
        "</b>"
      )
      .on("click", clickZoom);
  }
};
const layersContainer = document.querySelector(".layers");

const layersButton = "all layers";

function generateButton(name) {
  const id = name === layersButton ? "all-layers" : name;

  const templateLayer = `
    <li class="layer-element">
      <label for="${id}">
        <input type="checkbox" id="${id}" name="item" class="item" value="${name}" checked>
        <span>${name}</span>
      </label>
    </li>
  `;

  layersContainer.insertAdjacentHTML("beforeend", templateLayer);

  // ƒê·∫£m b·∫£o s·ª± ki·ªán ƒë∆∞·ª£c th√™m sau khi n√∫t ƒë∆∞·ª£c t·∫°o ra
  const checkbox = document.querySelector(`#${id}`);
  checkbox.addEventListener("change", (e) => {
    console.log(`${name} checkbox clicked. Checked: ${e.target.checked}`);
    showHideLayer(e.target);
  });
}

generateButton(layersButton);

// add data to geoJSON layer and add to LayerGroup
const arrayLayers = ["cinema"]; // Changed to include only "cinema"

arrayLayers.map((json) => {
  generateButton(json);
  fetchData(`/static/data/${json}.json`).then((data) => {
    window["layer_" + json] = L.geoJSON(data, geojsonOpts).addTo(map);
  });
});

document.addEventListener("click", (e) => {
  const target = e.target;

  const itemInput = target.closest(".item");

  if (!itemInput) return;

  console.log("Checkbox clicked:", target); // Ki·ªÉm tra khi checkbox ƒë∆∞·ª£c nh·∫•n
  showHideLayer(target);
});

function showHideLayer(target) {
  console.log("showHideLayer called for:", target.id); // Ki·ªÉm tra h√†m showHideLayer

  if (target.id === "all-layers") {
    console.log("All layers checkbox changed.");
    arrayLayers.map((json) => {
      checkedType(json, target.checked);
    });
  } else {
    checkedType(target.id, target.checked);
  }
  const checkedBoxes = document.querySelectorAll("input[name=item]:checked");
  document.querySelector("#all-layers").checked =
    checkedBoxes.length - (document.querySelector("#all-layers").checked === true ? 1 : 0) < 1 ? false : true;
}
function checkedType(id, type) {
  console.log("checkedType called for:", id, type); // Ki·ªÉm tra xem c√≥ th√™m ho·∫∑c x√≥a layer kh√¥ng
  map[type ? "addLayer" : "removeLayer"](window["layer_" + id]);

  if (window["layer_" + id]) {
    map.fitBounds(window["layer_" + id].getBounds(), { padding: [50, 50] });
  }

  document.querySelector(`#${id}`).checked = type;
}
// Th√™m th∆∞ vi·ªán Leaflet Routing Machine n·∫øu ch∆∞a c√≥
// < link rel = "stylesheet" href = "https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.css" />
//   <script src="https://unpkg.com/leaflet-routing-machine/dist/leaflet-routing-machine.js"></script>
let routingControl; // Bi·∫øn l∆∞u tuy·∫øn ƒë∆∞·ªùng
// H√†m ch·ªâ ƒë∆∞·ªùng t·ª´ v·ªã tr√≠ hi·ªán t·∫°i ƒë·∫øn m·ªôt ƒëi·ªÉm ƒë√≠ch (r·∫°p chi·∫øu phim)
function routeToDestination(destination) {
  if (navigator.geolocation) {
    navigator.geolocation.getCurrentPosition(
      function (position) {
        const userLat = position.coords.latitude;
        const userLng = position.coords.longitude;
        // X√≥a tuy·∫øn ƒë∆∞·ªùng c≈© n·∫øu c√≥
        if (routingControl) {
          map.removeControl(routingControl);
        }
        //T·∫°o tuy·∫øn ƒë∆∞·ªùng m·ªõi
        routingControl = L.Routing.control({
          waypoints: [L.latLng(userLat, userLng), destination], // T·ª´ v·ªã tr√≠ ng∆∞·ªùi d√πng ƒë·∫øn r·∫°p
          routeWhileDragging: true,
          createMarker: function () { return null; }, // Kh√¥ng hi·ªÉn th·ªã marker m·∫∑c ƒë·ªãnh
        }).addTo(map);
      },
      function () {
        alert("Kh√¥ng th·ªÉ l·∫•y v·ªã tr√≠ c·ªßa b·∫°n!");
      },
      { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
    );
  } else {
    alert("Tr√¨nh duy·ªát c·ªßa b·∫°n kh√¥ng h·ªó tr·ª£ ƒë·ªãnh v·ªã.");
  }
}
// C·∫≠p nh·∫≠t s·ª± ki·ªán click tr√™n r·∫°p chi·∫øu phim
geojsonOpts = {
  pointToLayer: function (feature, latlng) {
    let iconHtml = "üé•"; // Bi·ªÉu t∆∞·ª£ng r·∫°p chi·∫øu phim
    return L.marker(latlng, {
      icon: L.divIcon({
        className: "cinema-icon", // S·ª≠ d·ª•ng CSS ƒë·ªÉ l√†m ƒë·∫πp
        html: "<span class='emoji'>üé•</span>", // Ch·ªâ hi·ªÉn th·ªã emoji
        iconSize: [40, 40], // K√≠ch th∆∞·ªõc t·ªïng th·ªÉ
        iconAnchor: [20, 20], // CƒÉn gi·ªØa icon
        popupAnchor: [0, -25], // ƒêi·ªÅu ch·ªânh v·ªã tr√≠ popup
      }),
    })
      .bindPopup(`<b>R·∫°p chi·∫øu phim:</b> ${feature.properties.name} <br><button onclick="routeToDestination([${latlng.lat}, ${latlng.lng}])">Ch·ªâ ƒë∆∞·ªùng</button>`)
      .on("click", function () {
        map.setView(latlng, zoom);
      });
  },
};


